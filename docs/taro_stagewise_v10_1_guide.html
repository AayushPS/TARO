<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TARO Stage-Wise Guide v10.1</title>
<style>
:root {
  --bg: #f8fafc;
  --fg: #111827;
  --muted: #374151;
  --card: #ffffff;
  --border: #d1d5db;
  --code: #eef2ff;
}
body {
  margin: 0;
  font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
  background: linear-gradient(160deg, #eef2ff 0%, #f8fafc 45%, #ecfeff 100%);
  color: var(--fg);
}
main {
  max-width: 960px;
  margin: 28px auto;
  padding: 24px 28px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 14px;
  box-shadow: 0 12px 28px rgba(17, 24, 39, 0.08);
}
h1,h2,h3 { line-height: 1.2; margin-top: 1.2em; margin-bottom: 0.4em; }
h1 { margin-top: 0; font-size: 2rem; }
h2 { font-size: 1.35rem; border-bottom: 1px solid var(--border); padding-bottom: 0.2rem; }
p, li { line-height: 1.5; color: var(--muted); }
code { background: var(--code); border: 1px solid #c7d2fe; padding: 0.08rem 0.35rem; border-radius: 6px; color: #312e81; }
pre { background: #111827; color: #e5e7eb; padding: 14px; border-radius: 10px; overflow-x: auto; }
pre code { background: transparent; border: none; color: inherit; padding: 0; }
ul, ol { margin-top: 0.4em; margin-bottom: 0.4em; }
@page { size: A4; margin: 12mm; }
</style>
</head>
<body>
<main>
<h1>TARO Stage-Wise Guide (v10.1, Implementation Aligned)</h1>

<p>Date: 2026-02-06  </p>
<p>Workspace: <code>TARO-TIME_AWARE_ROUTING_Orchestrator</code></p>

<h2>0. Direct Answer</h2>

<p>Your implementation up to Stage 6 still works.</p>

<p>You do not need a drastic rewrite from <code>taro_architecture_refined.pdf</code> for Stage 1-6. You needed contract hardening and loader/schema cleanup, which is now applied.</p>

<h2>1. What Was Rebuilt (Stage 1-6)</h2>

<h3>Stage 1: ID Translation Layer</h3>
<ul>
<li>Status: <code>DONE</code></li>
<li>Runtime: immutable read-only mapper (<code>FastUtilIDMapper</code>).</li>
<li>Contract kept: dense 0-indexed internal IDs, O(1) lookup semantics, thread-safe reads.</li>
</ul>

<h3>Stage 2: Temporal Utilities</h3>
<ul>
<li>Status: <code>DONE</code> (upgraded)</li>
<li>Added generic engine-time contract:</li>
</ul>
<p>  - <code>TimeUtils.EngineTimeUnit</code> (<code>SECONDS</code>, <code>MILLISECONDS</code>)</p>
<p>  - <code>normalizeToEngineTicks(...)</code></p>
<p>  - unit-aware bucket/day helpers</p>
<p>  - <code>tick_duration_ns</code> validation helpers</p>
<ul>
<li>Existing second-based APIs kept for compatibility.</li>
</ul>

<h3>Stage 3: FlatBuffers Model Contract</h3>
<ul>
<li>Status: <code>DONE</code> (upgraded)</li>
<li><code>taro_model.fbs</code> updated with v10.1 metadata contract:</li>
</ul>
<p>  - <code>schema_version</code></p>
<p>  - <code>model_version</code></p>
<p>  - <code>time_unit</code></p>
<p>  - <code>tick_duration_ns</code></p>
<p>  - <code>profile_timezone</code></p>
<p>  - <code>traits_hash</code></p>
<p>  - <code>model_hash</code></p>
<ul>
<li>Java/Python FlatBuffers bindings regenerated.</li>
</ul>

<h3>Stage 4: Edge Graph (Physical Layer)</h3>
<ul>
<li>Status: <code>DONE</code> (hardened)</li>
<li><code>EdgeGraph.fromFlatBuffer(...)</code> now uses generated FlatBuffers model accessors (schema-safe root/topology loading).</li>
<li>Added vector length validation for <code>first_edge</code>, <code>edge_target</code>, <code>base_weights</code>, <code>edge_profile_id</code>, <code>edge_origin</code>.</li>
<li>Backward compatibility retained for missing <code>edge_origin</code> via computed fallback.</li>
</ul>

<h3>Stage 5: Turn Cost Lookup</h3>
<ul>
<li>Status: <code>DONE</code> (hardened)</li>
<li><code>TurnCostMap.fromFlatBuffer(...)</code> now uses generated <code>Model</code> + <code>TurnCost</code> accessors.</li>
<li>Removed brittle hardcoded root field index parsing.</li>
<li>Validation and duplicate-key overwrite behavior retained.</li>
</ul>

<h3>Stage 6: Search Infrastructure</h3>
<ul>
<li>Status: <code>DONE</code></li>
<li>Existing <code>SearchQueue</code>, <code>SearchState</code>, <code>VisitedSet</code> remain valid for v10.1 Stage 6 goals.</li>
<li>Tests remain green after Stage 2/3/4/5 upgrades.</li>
</ul>

<h2>2. Current Test Evidence</h2>

<p>Verified with clean run:</p>

<pre><code>
mvn -q clean test
</code></pre>

<p>Result: pass.</p>

<p>Main validated suites:</p>
<ul>
<li><code>org.Aayush.core.id.FastUtilIDMapperTest</code></li>
<li><code>org.Aayush.core.time.TimeUtilsTest</code></li>
<li><code>org.Aayush.routing.graph.EdgeGraphTest</code></li>
<li><code>org.Aayush.routing.graph.TurnCostMapTest</code></li>
<li><code>org.Aayush.routing.search.SearchInfrastructureTest</code></li>
<li><code>org.Aayush.serialization.flatbuffers.TaroModelTest</code></li>
</ul>

<h2>3. Stage-Wise Status Snapshot (v10.1)</h2>

<ul>
<li>Stage 1: <code>DONE</code></li>
<li>Stage 2: <code>DONE</code></li>
<li>Stage 3: <code>DONE</code></li>
<li>Stage 4: <code>DONE</code></li>
<li>Stage 5: <code>DONE</code></li>
<li>Stage 6: <code>DONE</code></li>
<li>Stage 7: <code>NOT STARTED</code></li>
<li>Stage 8: <code>NOT STARTED</code></li>
<li>Stage 9: <code>NOT STARTED</code></li>
<li>Stage 10: <code>NOT STARTED</code></li>
<li>Stage 11-28: <code>NOT STARTED</code> in this repo</li>
</ul>

<h2>4. Requirements Going Forward (All Stages, Condensed)</h2>

<h3>Stage 7: Live Overlay</h3>
<ul>
<li>Enforce <code>speed_factor</code> range <code>[0,1]</code>.</li>
<li><code>0.0</code> must mean blocked edge.</li>
<li>Normalize TTL to engine ticks (<code>valid_until_ticks</code>).</li>
<li>Use bounded memory strategy (hybrid cleanup + cap policy).</li>
<li>Keep read path cheap under concurrency.</li>
</ul>

<h3>Stage 8: Spatial Runtime</h3>
<ul>
<li>Implement KD query runtime over serialized spatial index.</li>
<li>Keep trait-driven optional enablement.</li>
</ul>

<h3>Stage 9: Profile Store</h3>
<ul>
<li>Profile/day-mask lookup with deterministic fallback.</li>
<li>Bucket interpolation policy must be explicit.</li>
</ul>

<h3>Stage 10: Cost Engine</h3>
<ul>
<li>Canonical rule: if live factor is 0 -&gt; INF.</li>
<li>Else: <code>effective = base * temporal / speed_factor</code>.</li>
<li>Expose explainable cost breakdown for debugging/telemetry.</li>
</ul>

<h3>Stage 11-14: Heuristics + Routing</h3>
<ul>
<li>Heuristic providers (null/euclidean/spherical/landmark) with admissibility tests.</li>
<li>Implement and verify TD-A* + one-to-many Dijkstra parity cases.</li>
</ul>

<h3>Stage 15-18: Trait Layer</h3>
<ul>
<li>Addressing/Temporal/Transition traits + registry.</li>
<li>Mark config fields as hot-reload-safe vs full-reload-required.</li>
</ul>

<h3>Stage 19-24: Python Build Pipeline</h3>
<ul>
<li>Ingestion + validation + connectivity lint.</li>
<li>Profile compression with FIFO guard.</li>
<li>Compile and serialize model with metadata lineage.</li>
</ul>

<h3>Stage 25-28: Loader/API/Prod</h3>
<ul>
<li>Full model loader with atomic reload.</li>
<li>Stable <code>/api/v1</code> contract.</li>
<li>Telemetry with lineage fields.</li>
<li>Production observability and alerting baselines.</li>
</ul>

<h2>5. Practical Impact for You</h2>

<p>How drastically to work differently now:</p>
<ul>
<li>Stage 1-6: low change, mostly keep building forward.</li>
<li>Stage 7-10: high semantic importance, lock these contracts before deep routing features.</li>
</ul>

<p>Recommended next order:</p>
<ol>
<li>Stage 7 (overlay)</li>
<li>Stage 9 (profile store)</li>
<li>Stage 10 (cost engine)</li>
<li>Stage 14 then Stage 13 (routing)</li>
</ol>
</main>
</body>
</html>
